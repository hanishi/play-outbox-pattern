play.modules.enabled += "modules.OutboxModule"

# Service Failure Simulation Rates (0.0 to 1.0)
# Used by service controllers to simulate real-world external service failures
service.failure.rates {
  # Forward endpoints (create/process operations)
  # Set to 0.0 for guaranteed success, or low values (0.1-0.2) for occasional failures
  billing.charge = 0.3          # 30% failure - billing intentionally fails to demo compensation
  inventory.reserve = 0.05       # 5% failure - mostly succeeds
  fraudCheck.check = 0.05        # 5% failure - mostly succeeds
  shipping.domestic.create = 0.05    # 5% failure - mostly succeeds
  shipping.international.create = 0.1  # 10% failure
  highValue.process = 0.2        # 20% failure for high-value orders

  # Revert endpoints (cancel/refund/release operations)
  billing.refund = 0.1
  inventory.release = 0.1
  shipping.domestic.cancel = 0.1
  shipping.international.cancel = 0.1
  highValue.cancel = 0.1
}

# HTTP endpoint configuration for external services
outbox.http {
  # Event-specific routes - maps destination names to actual service endpoints
  routes {
    # Inventory service - reserve and release stock
    inventory {
      url = "http://localhost:9000/api/inventory/reserve"
      method = "POST"
      timeout = 5 seconds

      # Revert configuration: called when event moves to DLQ
      # Extracts reservation ID from response and calls revert endpoint
      revert {
        url = "http://localhost:9000/api/inventory/{reservationId}/release"
        method = "DELETE"
        extract {
          reservationId = "response:$.reservationId"
        }
      }
    }

    # Fraud check - evaluates order risk before billing
    # Returns risk score that determines billing route
    fraudCheck {
      url = "http://localhost:9000/api/fraud/check"
      method = "POST"
      timeout = 5 seconds
      # No revert needed - fraud checks are read-only

      # Respect rate limits from fraud check API
      # Many fraud APIs (Stripe Radar, Sift, etc.) impose rate limits
      retryAfter {
        headerName = "Retry-After"
        format = "auto"  # Auto-detect: seconds, unix timestamp, ISO 8601, etc.
        fallbackSeconds = 30  # Default to 30s if header missing
      }
    }

    # Billing endpoint - ALWAYS FAILS to demonstrate SAGA compensation
    # Routes to different billing processors based on risk score from fraudCheck
    # Both routes intentionally fail to trigger automatic compensation
    billing {
      method = "POST"
      timeout = 5 seconds

      routes = [{
        # Low-risk orders: use standard billing
        url = "http://localhost:9000/api/billing"
        condition {
          jsonPath = "$.riskScore"
          operator = "lt"
          value = "50"
          previousDestination = "fraudCheck"  # Check fraudCheck API response
        }
        revert {
          url = "http://localhost:9000/api/billing/{transactionId}/refund"
          method = "POST"
          extract {
            transactionId = "response:$.transaction.id"
            amount = "request:$.amount"
            currency = "request:$.currency"
          }
          payload = """{"transactionId": "{transactionId}", "amount": "{amount}", "currency": "{currency}", "reason": "order_failed"}"""
        }
      }, {
        # High-risk orders: use high-value processor (FAILS to trigger compensation)
        url = "http://localhost:9000/api/high-value-processing"
        condition {
          jsonPath = "$.riskScore"
          operator = "gte"
          value = "50"
          previousDestination = "fraudCheck"  # Check fraudCheck API response
        }
        revert {
          url = "http://localhost:9000/api/high-value-processing/{processingId}/cancel"
          method = "POST"
          extract {
            processingId = "response:$.processingId"
            amount = "request:$.amount"
            currency = "request:$.currency"
          }
          payload = """{"processingId": "{processingId}", "amount": "{amount}", "currency": "{currency}", "reason": "order_failed"}"""
        }
      }]
    }

    # ============================================================================
    # MULTI-ROUTE CONDITIONAL ROUTING
    # ============================================================================

    # Multi-route shipping destination - routes to domestic or international based on shippingType
    shipping {
      method = "POST"
      timeout = 5 seconds

      # Multiple routes - first matching condition wins
      routes = [{
        url = "http://localhost:9000/api/domestic-shipping"
        condition {
          jsonPath = "$.shippingType"
          operator = "eq"
          value = "domestic"
        }
        revert {
          url = "http://localhost:9000/api/domestic-shipping/{shipmentId}/cancel"
          method = "POST"
          extract {
            shipmentId = "response:$.shipmentId"
            orderId = "response:$.orderId"
            customerId = "request:$.customerId"
          }
          payload = """{"reason": "payment_failed", "shipmentId": "{shipmentId}", "orderId": "{orderId}", "customerId": "{customerId}"}"""
        }
      }, {
        url = "http://localhost:9000/api/international-shipping"
        condition {
          jsonPath = "$.shippingType"
          operator = "eq"
          value = "international"
        }
        revert {
          url = "http://localhost:9000/api/international-shipping/{shipmentId}/cancel"
          method = "POST"
          extract {
            shipmentId = "response:$.shipmentId"
            orderId = "response:$.orderId"
            customerId = "request:$.customerId"
          }
          payload = """{"reason": "payment_failed", "shipmentId": "{shipmentId}", "orderId": "{orderId}", "customerId": "{customerId}"}"""
        }
      }]
    }

    # Notification service - conditional routing based on order status
    # Demonstrates status-based workflow triggers
    notifications {
      method = "POST"
      timeout = 5 seconds

      routes = [{
        # Send shipping confirmation when status changes to SHIPPED
        url = "http://localhost:9000/api/notifications/shipping-confirmation"
        condition {
          jsonPath = "$.newStatus"
          operator = "eq"
          value = "SHIPPED"
        }
      }, {
        # Send review request when status changes to DELIVERED
        url = "http://localhost:9000/api/notifications/review-request"
        condition {
          jsonPath = "$.newStatus"
          operator = "eq"
          value = "DELIVERED"
        }
      }, {
        # Catch-all for other status changes
        url = "http://localhost:9000/api/notifications/status-update"
        condition {
          jsonPath = "$.newStatus"
          operator = "ne"
          value = ""  # Always true (newStatus is never empty)
        }
      }]
    }
  }

  # Fan-out configuration: which event types trigger multiple destinations
  # Format: eventType = [list of destination names from routes above]
  fanout {
    # SAGA PATTERN DEMONSTRATION:
    # When OrderCreated event occurs, publish to these destinations sequentially:
    #
    # 1. inventory     → Reserves inventory (succeeds)
    # 2. fraudCheck    → Evaluates order risk (succeeds, returns riskScore)
    # 3. shipping      → Multi-route: domestic or international based on shippingType (succeeds)
    # 4. billing       → Multi-route: standard or high-value based on fraudCheck.riskScore
    #                     Uses previousDestination="fraudCheck" to check risk score
    #
    # When billing fails:
    # → Event moves to Dead Letter Queue (DLQ)
    # → DLQ processor automatically reverts in LIFO order:
    #    a. Revert shipping (cancel shipment)
    #    b. Skip fraudCheck (read-only, no revert needed)
    #    c. Revert inventory (release reservation)
    #
    # This demonstrates:
    # - Multi-route conditional routing (shipping based on request, billing based on fraudCheck response)
    # - previousDestination usage (billing routes based on fraudCheck.riskScore)
    # - Saga pattern with automatic compensation
    # - LIFO revert order (automatic - uses '!' prefix, e.g., !OrderCreated)
    #
    # Revert events use '!' prefix convention:
    # - !OrderCreated automatically derives: reverse(OrderCreated fanout), filter to routes with revert config
    # - No need to explicitly list revert destinations
    # - LIFO order is automatic (billing -> shipping -> inventory, skipping fraudCheck which has no revert)
    OrderCreated = ["inventory", "fraudCheck", "shipping", "billing"]

    # STATUS UPDATE WORKFLOW DEMONSTRATION:
    # When OrderStatusUpdated event occurs, publish to notifications service.
    #
    # The notifications destination uses multi-route conditional routing:
    #    - SHIPPED → shipping-confirmation endpoint (sends tracking email)
    #    - DELIVERED → review-request endpoint (asks for product review)
    #    - Other → generic status-update endpoint (logs status change)
    #
    # This demonstrates:
    # - Conditional routing based on event payload (newStatus field)
    # - Different actions for different status values within same destination
    # - Real-world use case: automated customer notifications at key milestones
    OrderStatusUpdated = ["notifications"]
  }
}

outbox {
  pollInterval = 2 seconds  # Polling interval when LISTEN/NOTIFY is disabled
  batchSize = 100
  poolSize = 3
  maxRetries = 3  # Number of retry attempts before moving to DLQ
  useListenNotify = true  # Enable PostgreSQL LISTEN/NOTIFY for near-instant processing (default: true)
  # When enabled, new events are processed instantly via LISTEN/NOTIFY
  # Failed events and full batches trigger immediate reprocessing (100ms)

  # Stale event recovery settings
  enableStaleEventCleanup = true  # Enable automatic recovery of stale PROCESSING events (default: true)
  staleEventTimeoutMinutes = 5    # Consider events stale after this many minutes (default: 5)
  cleanupInterval = 1 minute      # How often to run cleanup (default: 1 minute)

  # DLQ (Dead Letter Queue) settings - for automatic saga compensation/revert
  dlq {
    maxRetries = 3  # Number of retry attempts for revert operations (compensating transactions)
    pollInterval = 2 seconds  # How often to check for pending DLQ events
  }
}

slick {
  dbs {
    default {
      profile = "slick.jdbc.PostgresProfile$"
      db {
        connectionPool = "HikariCP"
        driver = "org.postgresql.Driver"
        url = "jdbc:postgresql://localhost:5432/outbox_db"
        user = "outbox_user"
        password = "outbox_pass"
        numThreads = 50
        maximumPoolSize = 50
        minimumIdle = 0
      }
    }
  }
}

blocking-jdbc {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor {fixed-pool-size = 10}
  throughput = 50
}

