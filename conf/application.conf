play.modules.enabled += "modules.OutboxModule"

# HTTP endpoints to use local simulator
outbox.http {
  # Point to local simulator instead of external service 
  baseUrl = "http://localhost:9000/simulator"

  # Default endpoint - randomly fails 30% of the time
  defaultUrl = "http://localhost:9000/simulator/webhook/default"
  defaultMethod = "POST"

  defaultHeaders {
    "X-Service" = "outbox-local-test"
  }

  # Event-specific routes using simulator
  routes {
    OrderCreated {
      url = "http://localhost:9000/simulator/webhook/orders/created"
      //      url = "http://localhost:9000/simulator/always-429"
      method = "POST"
      timeout = 5 seconds

      # Revert by deleting the created order
      revert {
        url = "http://localhost:9000/simulator/webhook/orders/{orderId}"
        method = "DELETE"
        extract {
          orderId = "response:$.orderId"
        }
      }
    }

    OrderStatusUpdated {
      url = "http://localhost:9000/simulator/webhook/orders/status"
      method = "PUT"
      timeout = 5 seconds
      # No revert - status updates are not easily reversible without tracking history
    }

    OrderCancelled {
      # Test with endpoint that always succeeds
      url = "http://localhost:9000/simulator/always-succeed"
      method = "POST"
      timeout = 5 seconds
      # No revert - cancellations are final business decisions
    }

    # Additional endpoints for fan-out demo
    inventory {
      url = "http://localhost:9000/simulator/webhook/inventory"
      method = "POST"
      timeout = 5 seconds

      # Revert configuration: called when event moves to DLQ
      # Extracts reservation ID from response and calls revert endpoint
      revert {
        url = "http://localhost:9000/simulator/webhook/inventory/{reservationId}"
        method = "DELETE"
        extract {
          reservationId = "response:$.reservationId"
        }
      }
    }

    # Fraud check - evaluates order risk before billing
    # Returns risk score that determines billing route
    fraudCheck {
      url = "http://localhost:9000/simulator/fraud/check"
      method = "POST"
      timeout = 5 seconds
      # No revert needed - fraud checks are read-only

      # Respect rate limits from fraud check API
      # Many fraud APIs (Stripe Radar, Sift, etc.) impose rate limits
      retryAfter {
        headerName = "Retry-After"
        format = "auto"  # Auto-detect: seconds, unix timestamp, ISO 8601, etc.
        fallbackSeconds = 30  # Default to 30s if header missing
      }
    }

    # Billing endpoint - ALWAYS FAILS to demonstrate SAGA compensation
    # Routes to different billing processors based on risk score from fraudCheck
    # Both routes intentionally fail to trigger automatic compensation
    billing {
      method = "POST"
      timeout = 5 seconds

      routes = [
        {
          # Low-risk orders: use standard billing
          url = "http://localhost:9000/simulator/always-succeed"
          condition {
            jsonPath = "$.riskScore"
            operator = "lt"
            value = "50"
            previousDestination = "fraudCheck"  # Check fraudCheck API response
          }
          revert {
            url = "http://localhost:9000/simulator/webhook/billing/{transactionId}/refund"
            method = "POST"
            extract {
              transactionId = "response:$.transaction.id"
              amount = "request:$.amount"
              currency = "request:$.currency"
            }
            payload = """{"transactionId": "{transactionId}", "amount": "{amount}", "currency": "{currency}", "reason": "order_failed"}"""
          }
        },
        {
          # High-risk orders: use high-value processor (FAILS to trigger compensation)
          url = "http://localhost:9000/simulator/always-fail"
          condition {
            jsonPath = "$.riskScore"
            operator = "gte"
            value = "50"
            previousDestination = "fraudCheck"  # Check fraudCheck API response
          }
          revert {
            url = "http://localhost:9000/simulator/webhook/high-value-processing/{processingId}/cancel"
            method = "POST"
            extract {
              processingId = "response:$.processingId"
              amount = "request:$.amount"
            }
            payload = """{"processingId": "{processingId}", "amount": "{amount}", "reason": "order_failed"}"""
          }
        }
      ]
    }

    # ============================================================================
    # MULTI-ROUTE CONDITIONAL ROUTING
    # ============================================================================

    # Multi-route shipping destination - routes to domestic or international based on shippingType
    shipping {
      method = "POST"
      timeout = 5 seconds

      # Multiple routes - first matching condition wins
      routes = [
        {
          url = "http://localhost:9000/simulator/webhook/domestic-shipping"
          condition {
            jsonPath = "$.shippingType"
            operator = "eq"
            value = "domestic"
          }
          revert {
            url = "http://localhost:9000/simulator/webhook/domestic-shipping/{shipmentId}/cancel"
            method = "POST"
            extract {
              shipmentId = "response:$.shipmentId"
              orderId = "response:$.orderId"
              customerId = "request:$.customerId"
            }
            payload = """{"reason": "payment_failed", "shipmentId": "{shipmentId}", "orderId": "{orderId}", "customerId": "{customerId}"}"""
          }
        },
        {
          url = "http://localhost:9000/simulator/webhook/international-shipping"
          condition {
            jsonPath = "$.shippingType"
            operator = "eq"
            value = "international"
          }
          revert {
            url = "http://localhost:9000/simulator/webhook/international-shipping/{shipmentId}/cancel"
            method = "POST"
            extract {
              shipmentId = "response:$.shipmentId"
              orderId = "response:$.orderId"
              customerId = "request:$.customerId"
            }
            payload = """{"reason": "payment_failed", "shipmentId": "{shipmentId}", "orderId": "{orderId}", "customerId": "{customerId}"}"""
          }
        }
      ]
    }
  }

  # Fan-out configuration: which event types trigger multiple destinations
  # Format: eventType = [list of destination names from routes above]
  fanout {
    # SAGA PATTERN DEMONSTRATION:
    # When OrderCreated event occurs, publish to these destinations sequentially:
    #
    # 1. inventory     → Reserves inventory (succeeds)
    # 2. fraudCheck    → Evaluates order risk (succeeds, returns riskScore)
    # 3. shipping      → Multi-route: domestic or international based on shippingType (succeeds)
    # 4. billing       → Multi-route: standard or high-value based on fraudCheck.riskScore
    #                     Uses previousDestination="fraudCheck" to check risk score
    #
    # When billing fails:
    # → Event moves to Dead Letter Queue (DLQ)
    # → DLQ processor automatically reverts in LIFO order:
    #    a. Revert shipping (cancel shipment)
    #    b. Skip fraudCheck (read-only, no revert needed)
    #    c. Revert inventory (release reservation)
    #
    # This demonstrates:
    # - Multi-route conditional routing (shipping based on request, billing based on fraudCheck response)
    # - previousDestination usage (billing routes based on fraudCheck.riskScore)
    # - Saga pattern with automatic compensation
    # - LIFO revert order (opposite of execution, skipping read-only operations)
    OrderCreated = ["inventory", "fraudCheck", "shipping", "billing"]
  }
}

outbox {
  pollInterval = 2 seconds  # Polling interval when LISTEN/NOTIFY is disabled
  batchSize = 100
  poolSize = 3
  maxRetries = 3  # Number of retry attempts before moving to DLQ
  useListenNotify = true  # Enable PostgreSQL LISTEN/NOTIFY for near-instant processing (default: true)
  # When enabled, new events are processed instantly via LISTEN/NOTIFY
  # Failed events and full batches trigger immediate reprocessing (100ms)

  # Stale event recovery settings
  enableStaleEventCleanup = true  # Enable automatic recovery of stale PROCESSING events (default: true)
  staleEventTimeoutMinutes = 5    # Consider events stale after this many minutes (default: 5)
  cleanupInterval = 1 minute      # How often to run cleanup (default: 1 minute)

  # DLQ (Dead Letter Queue) settings - for automatic saga compensation/revert
  dlq {
    maxRetries = 3  # Number of retry attempts for revert operations (compensating transactions)
    pollInterval = 2 seconds  # How often to check for pending DLQ events
  }
}

simulator {
  failureRate = 0.5  # 50% failure rate
  slowResponseRate = 0.3  # 30% slow responses
  slowResponseDelayMs = 1000  # 1 second delay
}

slick {
  dbs {
    default {
      profile = "slick.jdbc.PostgresProfile$"
      db {
        connectionPool = "HikariCP"
        driver = "org.postgresql.Driver"
        url = "jdbc:postgresql://localhost:5432/outbox_db"
        user = "outbox_user"
        password = "outbox_pass"
        numThreads = 50
        maximumPoolSize = 50
        minimumIdle = 0
      }
    }
  }
}

blocking-jdbc {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor {fixed-pool-size = 10}
  throughput = 50
}

