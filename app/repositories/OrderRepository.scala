package repositories

import models.{ Order, OrderCancelledEvent, OrderCreatedEvent, OrderStatusUpdatedEvent }
import repositories.OutboxEventsPostgresProfile.api.*

import java.time.Instant
import javax.inject.*
import scala.concurrent.ExecutionContext

class OrderTable(tag: Tag) extends Table[Order](tag, "orders") {
  def * = (id, customerId, totalAmount, shippingType, orderStatus, createdAt, updatedAt, deleted)
    .mapTo[Order]

  def id = column[Long]("id", O.PrimaryKey, O.AutoInc)

  def customerId = column[String]("customer_id")

  def totalAmount = column[BigDecimal]("total_amount")

  def shippingType = column[String]("shipping_type")

  def orderStatus = column[String]("order_status")

  def createdAt = column[Instant]("created_at")

  def updatedAt = column[Instant]("updated_at")

  def deleted = column[Boolean]("deleted")
}

/** Repository for order persistence with transactional outbox pattern.
  *
  * == Purpose ==
  * Ensures order state changes and event publishing happen atomically within the same database transaction.
  * Uses OutboxHelper mixin to guarantee events are never lost, even if external systems fail.
  *
  * == Transactional Guarantees ==
  * All state-changing methods use OutboxHelper to provide:
  * - '''Atomicity''': Order changes and outbox events committed together or rolled back together
  * - '''Durability''': Events persisted in outbox table, will be published even after app crashes
  * - '''Exactly-once semantics''': Idempotency keys prevent duplicate event publishing
  *
  * == Event Flow ==
  * {{{
  * # 1. Create Order
  * createWithEvent(order)
  * → BEGIN TRANSACTION
  *   → INSERT INTO orders (customer_id, total_amount, shipping_type) VALUES (...)
  *   → INSERT INTO outbox_events (event_type='OrderCreated', aggregate_id='123', payloads={...})
  * → COMMIT
  * → OutboxProcessor picks up event → fan-out to: inventory, fraudCheck, shipping, billing
  *
  * # 2. Update Order Status
  * updateStatusWithEvent(orderId=123, newStatus="SHIPPED")
  * → BEGIN TRANSACTION
  *   → UPDATE orders SET order_status='SHIPPED', updated_at=NOW() WHERE id=123
  *   → INSERT INTO outbox_events (event_type='OrderStatusUpdated', aggregate_id='123')
  * → COMMIT
  * → OutboxProcessor picks up event → fan-out to: notifications (shipping-confirmation)
  *
  * # 3. Cancel Order (Manual Compensation)
  * cancelWithEvent(orderId=123, reason="Customer requested")
  * → BEGIN TRANSACTION
  *   → UPDATE orders SET order_status='CANCELLED', updated_at=NOW() WHERE id=123
  *   → INSERT INTO outbox_events (event_type='!OrderCreated', aggregate_id='123')
  * → COMMIT
  * → HttpEventPublisher processes !OrderCreated → LIFO compensation: billing, shipping, inventory
  * }}}
  *
  * == Why OutboxHelper ==
  * Without OutboxHelper (naive approach):
  * {{{
  * # ❌ Problem: Events can be lost
  * db.run(orders += order)  // Transaction 1: committed
  * publisher.publish(OrderCreatedEvent)  // Separate call: app crashes → event lost!
  * }}}
  *
  * With OutboxHelper (transactional outbox):
  * {{{
  * # ✓ Solution: Events persisted atomically
  * db.run(createWithEvent(order))  // Single transaction: both order + event committed together
  * # Even if app crashes, OutboxProcessor will pick up the event on restart
  * }}}
  */
@Singleton
class OrderRepository @Inject() ()(using ec: ExecutionContext) extends OutboxHelper {
  private val orders = TableQuery[OrderTable]

  /** Creates an order and publishes OrderCreatedEvent atomically.
    *
    * Uses OutboxHelper.withEventFactory to ensure both the order insertion and event creation
    * happen in the same database transaction. The order ID is generated by the database and
    * passed to the event factory.
    *
    * == Example ==
    * {{{
    * val order = Order(
    *   customerId = "customer-123",
    *   totalAmount = 99.99,
    *   shippingType = "domestic",
    *   orderStatus = "PENDING"
    * )
    *
    * db.run(createWithEvent(order))
    * # → Returns: orderId (e.g., 123)
    *
    * # Database state after commit:
    * # orders table:
    * #   id=123, customer_id='customer-123', total_amount=99.99, order_status='PENDING'
    *
    * # outbox_events table:
    * #   event_type='OrderCreated', aggregate_id='123',
    * #   payloads={
    * #     "inventory": {"orderId": 123, "totalAmount": 99.99, "shippingType": "domestic"},
    * #     "fraudCheck": {...},
    * #     "shipping": {"customerId": "customer-123", "shippingType": "domestic"},
    * #     "billing": {"amount": 99.99, "currency": "USD"}
    * #   }
    *
    * # Next: OutboxProcessor publishes to inventory → fraudCheck → shipping → billing
    * }}}
    *
    * @param order The order to create (id will be auto-generated)
    * @return DBIO action that returns the generated order ID
    */
  def createWithEvent(order: Order): DBIO[Long] =
    withEventFactory((orders returning orders.map(_.id)) += order) { orderId =>
      OrderCreatedEvent(
        orderId      = orderId,
        customerId   = order.customerId,
        totalAmount  = order.totalAmount,
        shippingType = order.shippingType
      )
    }

  /** Updates order status and publishes OrderStatusUpdatedEvent atomically.
    *
    * Used to track order lifecycle progression (PENDING → SHIPPED → DELIVERED).
    * Publishes events that trigger status-based workflow actions via conditional routing.
    *
    * == Example: Shipping Confirmation ==
    * {{{
    * db.run(updateStatusWithEvent(orderId=123, newStatus="SHIPPED"))
    *
    * # Transaction:
    * # 1. UPDATE orders SET order_status='SHIPPED', updated_at=NOW() WHERE id=123
    * # 2. INSERT INTO outbox_events (
    * #      event_type='OrderStatusUpdated',
    * #      aggregate_id='123',
    * #      payloads={"notifications": {"orderId": 123, "oldStatus": "PENDING", "newStatus": "SHIPPED"}}
    * #    )
    *
    * # Event processing:
    * # → OutboxProcessor publishes to notifications destination
    * # → Conditional routing: newStatus="SHIPPED" → shipping-confirmation endpoint
    * # → Customer receives tracking email
    * }}}
    *
    * == Example: Delivery Confirmation ==
    * {{{
    * db.run(updateStatusWithEvent(orderId=123, newStatus="DELIVERED"))
    *
    * # Event processing:
    * # → Conditional routing: newStatus="DELIVERED" → review-request endpoint
    * # → Customer receives review request email
    * }}}
    *
    * == Status Progression ==
    * - PENDING → SHIPPED: Triggers shipping confirmation notification
    * - SHIPPED → DELIVERED: Triggers review request notification
    * - Other transitions: Generic status update notification
    *
    * @param orderId The order ID to update
    * @param newStatus The new status value (e.g., "SHIPPED", "DELIVERED")
    * @return DBIO action that returns number of rows updated (1 if successful)
    * @throws NoSuchElementException if order not found
    */
  def updateStatusWithEvent(orderId: Long, newStatus: String): DBIO[Int] =
    for {
      orderOpt <- findById(orderId)
      order <- orderOpt match {
        case Some(o) => DBIO.successful(o)
        case None => DBIO.failed(new NoSuchElementException(s"Order $orderId not found"))
      }
      updated <- withEvent(
        OrderStatusUpdatedEvent(
          orderId   = orderId,
          oldStatus = order.orderStatus,
          newStatus = newStatus
        )
      ) {
        orders
          .filter(_.id === orderId)
          .map(o => (o.orderStatus, o.updatedAt))
          .update((newStatus, Instant.now()))
      }
    } yield updated

  /** Finds an order by ID, excluding soft-deleted orders.
    *
    * @param id The order ID
    * @return DBIO action that returns Some(order) if found, None otherwise
    */
  def findById(id: Long): DBIO[Option[Order]] =
    orders.filter(o => o.id === id && o.deleted === false).result.headOption

  /** Cancels an order and triggers manual Saga compensation.
    *
    * Publishes OrderCancelledEvent with eventType="!OrderCreated" (! prefix triggers revert).
    * Automatically undoes all previously successful operations in LIFO order.
    *
    * == Flow ==
    * {{{
    * # User clicks "Cancel Order" button
    * db.run(cancelWithEvent(orderId=123, reason="Customer requested"))
    *
    * # Transaction:
    * # 1. UPDATE orders SET order_status='CANCELLED', updated_at=NOW() WHERE id=123
    * # 2. INSERT INTO outbox_events (
    * #      event_type='!OrderCreated',  -- ! prefix = revert event
    * #      aggregate_id='123',
    * #      payloads={}  -- Empty, will query aggregate_results for forward data
    * #    )
    *
    * # Compensation (HttpEventPublisher):
    * # 1. Query aggregate_results for successful forward calls (ORDER BY fanout_order DESC)
    * #    → Returns: [billing(failed), shipping(success), fraudCheck(success), inventory(success)]
    * # 2. LIFO compensation: shipping → inventory (fraudCheck skipped, billing failed so not reverted)
    * #    → POST /api/domestic-shipping/{shipmentId}/cancel
    * #    → DELETE /api/inventory/{reservationId}/release
    * }}}
    *
    * == Compensation Details ==
    * {{{
    * # For each successful forward destination (in reverse order):
    * # 1. Query aggregate_results to get forward request/response
    * # 2. Extract values using JSONPath from revert config
    * # 3. Build revert endpoint URL and payload
    * # 4. Call revert API
    * # 5. Gracefully skip if no revert config (e.g., fraudCheck is read-only)
    *
    * # Example: Shipping revert
    * # Forward result: POST /api/domestic-shipping
    * #   Request:  {"customerId": "C-123", "shippingType": "domestic"}
    * #   Response: {"shipmentId": "SHIP-DOM-456", "orderId": "123"}
    * # Revert config extract:
    * #   shipmentId = "response:$.shipmentId"  → "SHIP-DOM-456"
    * #   orderId = "response:$.orderId"        → "123"
    * #   customerId = "request:$.customerId"   → "C-123"
    * # Built revert: POST /api/domestic-shipping/SHIP-DOM-456/cancel
    * #   Payload: {"reason": "payment_failed", "shipmentId": "SHIP-DOM-456", ...}
    * }}}
    *
    * == Use Cases ==
    * - Customer cancellation before shipment
    * - Payment failure requiring rollback
    * - Fraud detection requiring order reversal
    * - Inventory adjustment requiring reservation release
    *
    * @param orderId The order ID to cancel
    * @param reason Cancellation reason (e.g., "Customer requested", "Payment failed")
    * @return DBIO action that returns number of rows updated (1 if successful)
    * @throws NoSuchElementException if order not found
    */
  def cancelWithEvent(orderId: Long, reason: String): DBIO[Int] =
    for {
      orderOpt <- findById(orderId)
      _ <- orderOpt match {
        case Some(_) => DBIO.successful(())
        case None => DBIO.failed(new NoSuchElementException(s"Order $orderId not found"))
      }
      updated <- withEvent(
        OrderCancelledEvent(
          orderId = orderId,
          reason  = reason
        )
      ) {
        orders
          .filter(_.id === orderId)
          .map(o => (o.orderStatus, o.updatedAt))
          .update(("CANCELLED", Instant.now()))
      }
    } yield updated

  /** Lists orders sorted by creation date (newest first), with pagination.
    *
    * Excludes soft-deleted orders. Used by UI to display order history.
    *
    * @param limit Maximum number of orders to return (default: 50)
    * @param offset Number of orders to skip for pagination (default: 0)
    * @return DBIO action that returns sequence of orders
    */
  def list(limit: Int = 50, offset: Int = 0): DBIO[Seq[Order]] =
    orders
      .filter(_.deleted === false)
      .sortBy(_.createdAt.desc)
      .drop(offset)
      .take(limit)
      .result

  /** Soft-deletes an order by setting deleted flag to true.
    *
    * Used for cleanup after failed orders. Soft-deleted orders are excluded from queries.
    * Does NOT publish any events (cleanup operation, not a business event).
    *
    * @param orderId The order ID to mark as deleted
    * @return DBIO action that returns number of rows updated (1 if successful)
    */
  def markDeleted(orderId: Long): DBIO[Int] =
    orders
      .filter(_.id === orderId)
      .map(_.deleted)
      .update(true)
}
